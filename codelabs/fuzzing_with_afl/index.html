
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Fuzzing softwares with AFL</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://fuzzing.in/elements/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="fuzzing_with_afl"
                  title="Fuzzing softwares with AFL"
                  environment="web"
                  feedback-link="http://fuzzing.in">
    
      <google-codelab-step label="Introduction" duration="3">
        <p><strong>Welcome to RSA Dark Arts Village 2022</strong></p>
<p>This talk is aimed at providing hands on details on how to fuzz open source softwares on linux OS with AFL.</p>
<h2 is-upgraded>What will be covered</h2>
<ol type="1">
<li>How does a coverage guided fuzzer works?</li>
<li>How to install AFL on linux based systems?</li>
<li>How to fuzz a simple C program using AFL?</li>
<li>How to fuzz TcpDump using AFL.</li>
<li>Reporting crashes and bug bounties</li>
<li>Conclusion</li>
</ol>
<h2 is-upgraded>What is needed</h2>
<ol type="1">
<li>A laptop/desktop with atleast 8gb RAM and 40GB storage.</li>
<li>Vmware/virtualbox installed.</li>
<li>Internet connection.</li>
<li>willingness to learn :)</li>
</ol>
<h2 is-upgraded>Training VM Download</h2>
<p><a href="https://drive.google.com/drive/folders/1vqdjpVh6kXP-mXWV_MCKn4NS_N4DsFw5" target="_blank">Click Here</a></p>
<p>Zip File password: infected</p>
<p>user name: kali</p>
<p>password: kali</p>


      </google-codelab-step>
    
      <google-codelab-step label="About Me" duration="2">
        <p><strong>Current: Principal Researcher @ Sophos, Bangalore, India</strong></p>
<p><strong>Past: Senior Security Researcher @ McAfee, Bangalore,India</strong></p>
<p><strong>Past: Security Researcher @ Symantec, Pune, India</strong></p>
<p class="image-container"><img alt="Hardik Shah" src="img/8cafa15be2f5cbaf.png"></p>
<p><strong>What I do?</strong></p>
<ul>
<li>Vulnerability, exploits, malware analysis.</li>
<li>Fuzzing and bug hunting.</li>
<li>Have around <strong>30+ CVEs</strong> in my name in various closed source and open source software and libraries including windows GDI,libtiff, tcpdump, Jet Database Engine etc.</li>
<li><strong>MSRC 2018-19</strong> Most Valuable Researcher.</li>
<li><strong>MSRC Q1 2020</strong> Top Contributing Researcher.</li>
</ul>
<p><strong>Official Blogs: </strong><a href="https://news.sophos.com/en-us/author/hardik-shah/" target="_blank">https://news.sophos.com/en-us/author/hardik-shah/</a></p>
<p><strong>Past Blogs: </strong><a href="https://www.mcafee.com/blogs/author/hardik-shah/" target="_blank">https://www.mcafee.com/blogs/author/hardik-shah/</a></p>
<p><strong>Twitter: </strong><a href="https://twitter.com/hardik05" target="_blank">@hardik05</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Fuzzing Theory" duration="10">
        <h2 is-upgraded>Bug Hunting</h2>
<h3 is-upgraded>Problem with the manual approach?</h3>
<ul>
<li>Manual code audit.</li>
<li>Takes lot of time. Very slow.</li>
<li>Not possible to cover all the code paths.</li>
<li>Large code base, not possible for a single person to do audit.</li>
<li>Not very productive.</li>
<li>Things can be missed.</li>
<li>Can not cover all the scenarios.</li>
</ul>
<h3 is-upgraded>Automated</h3>
<ul>
<li>Automate bug finding. Very fast.</li>
<li>Can cover most of the code paths.</li>
<li>No need to worry about size of the code.</li>
<li>Can be done by an individual.</li>
<li>Can be automated further to notify about crashes, issues.</li>
</ul>
<h3 is-upgraded>Fuzzing</h3>
<p>Fuzzing is the process of automated bug finding. A fuzzer will generate or provide crafted input to a program and will monitor its behaviour. if its crashes then test case can be saved to further analysis and reproduction.</p>
<p class="image-container"><img alt="fuzzing" src="img/b5f7fbb989687163.png"></p>
<h3 is-upgraded>Coverage guideded fuzzers</h3>
<p>Monitors program execution using compile time or runtime instrumentation and can generate new input files based on the paths taken.</p>
<ul>
<li>Mutates file and check for new code path coverage/crash</li>
<li><strong>New Code path -&gt; Add to Queue</strong></li>
<li><strong>Crash -&gt; Save the input</strong> ☺ <img alt="coverage guided fuzzer" src="img/e336e0f57eb6c644.png"></li>
</ul>
<p><strong>Example:</strong> AFL,Honggfuzz,libfuzzer</p>
<p>Very useful and successful in finding bugs.</p>
<h3 is-upgraded>Interesting case study:</h3>
<p>pulling jpeg out of thin air: <a href="https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html" target="_blank">https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html</a></p>
<pre><code language="language-bash" class="language-bash">$ mkdir in_dir
$ echo &#39;hello&#39; &gt;in_dir/hello
$ ./afl-fuzz -i in_dir -o out_dir ./jpeg-9a/djpeg
</code></pre>
<h2 is-upgraded>Basic blocks, Instrumentation and Code Coverage</h2>
<h3 is-upgraded>1. Basic block</h3>
<ul>
<li>Consecutive lines of code with <em>no branches.</em> (code before program has to select a path/after taking a new path.)</li>
<li>Entry point – control comes to this basic block.</li>
<li>Exit point – control goes to another basic block.</li>
</ul>
<p>Consider following code:</p>
<p class="image-container"><img alt="basic block" src="img/8e37ef0b3be2e893.png"></p>
<p>What it looks like in IDA: <img alt="basic block IDA" src="img/14b6132a28e9add8.png"></p>
<h3 is-upgraded>2. Code Coverage</h3>
<ul>
<li>Measure of the code covered by an input in a program.</li>
<li>More code paths covered by an input or set of inputs, more better.</li>
<li>More code coverage means higher the chances of finding bugs. <img alt="Code Coverage" src="img/afbabe6a6abeac40.png"></li>
</ul>
<h3 is-upgraded>3. Instrumentation?</h3>
<ul>
<li><strong>Compile time instrumentation</strong> - Adds instrumentation code at compile time. (used by afl/honggfuzz/libfuzzer when source code is avaialble)</li>
</ul>
<p class="image-container"><img alt="compile time instrumentation" src="img/c86ab442cf237e7e.png"></p>
<ul>
<li>Can automate things like coverage measurement, Removes manual efforts.</li>
</ul>
<h2 is-upgraded>If source code is not available.</h2>
<ul>
<li><strong>Runtime instrumentation</strong> - Used when source code is not available.</li>
</ul>
<p class="image-container"><img alt="runtime instrumentation" src="img/7fbe03c6b0222795.png"></p>
<ul>
<li>Adds instrumentation code at runtime. (Mostly used on windows, Dynamorio/Pin tools etc.)</li>
</ul>
<h2 is-upgraded>What Is AFL?</h2>
<ul>
<li>American Fuzzy Lop</li>
<li>Created by Michael Zelwaski</li>
<li>Fuzzer with instrumentation-guided genetic algorithm.</li>
<li>Comes with set of utilities:  afl-fuzz, afl-cmin, afl-tmin, afl-showmap etc..</li>
<li>Mutate the files based on various strategies.  Bitflip, byteflip, havoc, splice etc.</li>
</ul>
<h2 is-upgraded>Fuzzing strategies</h2>
<h3 is-upgraded>AFL uses following fuzzing strategies:</h3>
<table>
<tr><td colspan="1" rowspan="1"><p><strong>Fuzzing Strategy</strong></p>
</td><td colspan="1" rowspan="1"><p><strong>Details</strong></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Bit Flip</strong></p>
</td><td colspan="1" rowspan="1"><p>Flips a bit i.e. 1 becomes 0, 0 becomes 1 - this can be done in steps of 1⁄1,2⁄1,4⁄1,8⁄8 ....32⁄8 (same strategy will be used for byteflip as well)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Byte Flip</strong></p>
</td><td colspan="1" rowspan="1"><p>Flips a byte - this can be done in steps of 1⁄1,2⁄1,4⁄1,8⁄8 ....32⁄8</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Arithmetic</strong></p>
</td><td colspan="1" rowspan="1"><p>Random arithmetic like addition/substraction of random values</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Havoc</strong></p>
</td><td colspan="1" rowspan="1"><p>Random strategy - anythings from bit/bytes/interest/splice/addition/subtraction</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Dictionary</strong></p>
</td><td colspan="1" rowspan="1"><p>User provided dictionary or auto discovered tokens.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Interest</strong></p>
</td><td colspan="1" rowspan="1"><p>Replace content in original file with interesting values like: 0xff,0x7f etc – 8⁄8,16⁄8..</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Splice</strong></p>
</td><td colspan="1" rowspan="1"><p>Splits and combine two or more files to get a new file.</p>
</td></tr>
</table>
<p><strong>Reference:</strong></p>
<p><a href="https://github.com/google/AFL/blob/master/docs/technical_details.txt" target="_blank">https://github.com/google/AFL/blob/master/docs/technical_details.txt</a></p>
<h2 is-upgraded>Steps involved in the fuzzing:</h2>
<p class="image-container"><img alt="fuzzing Steps" src="img/1b1bec4ea359d33d.png"></p>
<h2 is-upgraded>Corpus Collection</h2>
<ul>
<li>A good file corpus will help to discover paths in short amount of time.</li>
<li>Use regression/test case corpus if available for the software/libs.</li>
</ul>
<p>Example:</p>
<ul>
<li><strong>Image file corpus</strong> -&gt; <a href="https://lcamtuf.coredump.cx/afl/demo/" target="_blank">https://lcamtuf.coredump.cx/afl/demo/</a></li>
<li><strong>Multimedia file corpus</strong> -&gt; <a href="http://samples.ffmpeg.org/" target="_blank">http://samples.ffmpeg.org/</a></li>
<li><strong>Others</strong> -&gt; Search github/google</li>
</ul>
<h2 is-upgraded>Corpus Mimization</h2>
<p>Why do we need to Minimize input corpus?</p>
<ul>
<li>Filter out the files which doesn&#39;t result in new path.</li>
<li>Filter out large files.</li>
</ul>
<p>How?</p>
<pre><code language="language-bash" class="language-bash">afl-cmin –i input –o mininput -- ./program @@
</code></pre>
<h2 is-upgraded>Fuzzing the program</h2>
<ul>
<li>will result in crash or hangs</li>
</ul>
<h2 is-upgraded>Crash Triaging and Minimisation</h2>
<ul>
<li>If multiple crashes then we need to remove duplicates.</li>
<li>We also need to remove unecessary data from crash files.</li>
</ul>
<h2 is-upgraded>Root cause analysis</h2>
<p>We found a crash by running fuzzer – now what?</p>
<ul>
<li>Which <strong>Field</strong> in file?</li>
<li>What <strong>Value</strong> in the field?</li>
<li>Which <strong>Condition</strong> in program? -&gt; <strong>=&gt;VULNERABILITY&lt;=</strong></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Hands on: Compiling and Installing AFL" duration="5">
        <pre><code language="language-bash" class="language-bash">$ git clone https://github.com/google/AFL.git
$ cd AFL
$ make
$ cd llvm_mode
$ make
$ cd ..
$ make install
</code></pre>
<p>This will install various compiler wrappers and utilities like:</p>
<ul>
<li><strong>afl-gcc,afl-clang,afl-clang-fast</strong> - these will be used to instrument and compile C code.</li>
<li><strong>afl-g++,afl-clang++,afl-clang-fast++</strong> - these will be used to instument and compile C++ code.</li>
<li><strong>afl-gotcpu</strong> - utility to check available CPU cores on the system.</li>
<li><strong>afl-cmin</strong> - utility to minimize corpus files, reduces <strong>number</strong> of files.</li>
<li><strong>afl-showmap</strong> - shows coverage map.</li>
<li><strong>afl-tmin</strong> - utility to trim a single file and removing other data which is not needed, reduces data in a <strong>single</strong> file.</li>
</ul>
<aside class="special"><p><strong>afl-cmin</strong> needs to be used before you start the fuzzing to minimize file corpus and <strong>afl-tmin</strong> needs to be used after you found a crash to reduce its size so that it helps in analysis.</p>
</aside>
<aside class="warning"><p>afl-tmin will take lot of time in minimising a file. in case you have huge input file corpus, be careful.</p>
</aside>
<aside class="special"><p>llvm_mode will enable support for afl-clang-fast and afl-clang-fast++. which will be used for persistent mode. This will require installation of clang and llvm on your system.</p>
</aside>
<p>you can install it by typing following command:</p>
<pre><code language="language-bash" class="language-bash">$ sudo apt install clang llvm
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Sanitizers and AFL Environment variables" duration="3">
        <p>santizers helps in finding bugs at the eary stages of program execution.</p>
<p>There are various types of sanitizers which can be enabled at compile time by passing required options. you need to add following flags at compile time if you want to enable any of the sanitizers below:</p>
<pre><code>1. ASAN (-fsanitize=address)
2. MSAN (-fsanitize=memory)
3. UBSAN (-fsanitize=undefined)
4. TSAN (-fsanitize=thread)
</code></pre>
<aside class="warning"><p>ASAN and MSAN are mutually exclusive.</p>
</aside>
<p class="image-container"><img alt="sanitizers" src="img/a99ef60c36df3b53.png"></p>
<p>AFL has various environment variables like AFL_HARDEN, AFL_USE_ASAN and AFL_USE_MSAN etc. which can be used to enable support for this sanitizers as well as to do various fuzzing related customization. check here: <a href="https://github.com/mirrorer/afl/blob/master/docs/env_variables.txt" target="_blank">https://github.com/mirrorer/afl/blob/master/docs/env_variables.txt</a></p>
<h2 is-upgraded>Reference:</h2>
<p><a href="https://clang.llvm.org/docs/AddressSanitizer.html" target="_blank">https://clang.llvm.org/docs/AddressSanitizer.html</a></p>
<p><a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html" target="_blank">https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html</a></p>
<p><a href="https://clang.llvm.org/docs/MemorySanitizer.html" target="_blank">https://clang.llvm.org/docs/MemorySanitizer.html</a></p>
<p><a href="https://clang.llvm.org/docs/ThreadSanitizer.html" target="_blank">https://clang.llvm.org/docs/ThreadSanitizer.html</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Fuzzing a simple C program with AFL" duration="5">
        <p><strong>Goal: learning how to fuzz a program with AFL.</strong></p>
<h2 is-upgraded>Fuzzing Damn vulnerable C program with AFL</h2>
<p>Lets download it first:</p>
<pre><code language="language-bash" class="language-bash">$ git clone https://github.com/hardik05/Damn_Vulnerable_C_Program.git
</code></pre>
<p>Let&#39;s compile it using afl-gcc/afl-clang(when nothing works, use afl-gcc,afl-g++) :</p>
<pre><code language="language-bash" class="language-bash">$ afl-gcc -fsanitize=address,undefined -ggdb -O0 imgRead.c -o imgRead_afl
</code></pre>
<p>Generate some seed corpus</p>
<pre><code language="language-bash" class="language-bash">$ mkdir in
$ echo &#34;IMG&#34; &gt; in/1.img
</code></pre>
<p>Fuzz it</p>
<pre><code language="language-bash" class="language-bash">$ afl-fuzz -i in -o out -m none -- ./imgRead_afl @@
</code></pre>
<p>you should see a screen like below: <img alt="afl run" src="img/355ed8887a7442a.gif"></p>
<p>It has various status messages.</p>
<p>not all are needed. you can read more about them here: <a href="https://github.com/google/AFL/blob/master/docs/status_screen.txt" target="_blank">https://github.com/google/AFL/blob/master/docs/status_screen.txt</a></p>
<ul>
<li><strong>Quick excercise, go to out directory and analyze various files and directory contents.</strong></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Fuzzing tcpdump" duration="10">
        <p>Get the source code of tcpdump and libpcap.</p>
<pre><code language="language-bash" class="language-bash">git clone https://github.com/the-tcpdump-group/tcpdump.git
cd tcpdump
git clone https://github.com/the-tcpdump-group/libpcap.git
cd libpcap
</code></pre>
<h2 is-upgraded>Compile it using AFL</h2>
<pre><code language="language-bash" class="language-bash">CC=afl-gcc CFLAGS=&#34;-g -fsanitize=address -fno-omit-frame-pointer&#34; LDFLAGS=&#34;-g -fsanitize=address -fno-omit-frame-pointer&#34; ./configure
sudo make &amp;&amp; make install
</code></pre>
<p>it will complain about some missing dependencies, run following commands:</p>
<pre><code language="language-bash" class="language-bash">sudo apt install flex bison
</code></pre>
<p>your compilation should be succssfull.</p>
<h2 is-upgraded>How to get test corpus?</h2>
<ul>
<li>Check tests folder ☺</li>
</ul>
<h2 is-upgraded>How to minimize it?</h2>
<p>use afl-cmin, run following command:</p>
<pre><code language="language-bash" class="language-bash">afl-cmin –i tests –o mincorpus –m none -- ./tcpdump –vv –ee –nnr @@
</code></pre>
<p>You should see a screenshot something like below: <img alt="afl-cmin" src="img/9a7292ab6f4b8503.gif"></p>
<h2 is-upgraded>Lets, Fuzz it!</h2>
<pre><code language="language-bash" class="language-bash">afl-fuzz –i mincorpus –o fuzzoutput –m none -- ./tcpdump –vv –ee –nnr @@
</code></pre>
<p>you should see something like this:</p>


      </google-codelab-step>
    
      <google-codelab-step label="Reporting bugs" duration="2">
        <p>✅ Always report to vendor first.generally vendor have security@vendor.com email id. you can also check their website for security contact.</p>
<p>✅ Dont disclose anything until vendor releases the patch.</p>
<p>✅ Vendors may reward you with bug bounty for your work!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Whats next?" duration="3">
        <ul>
<li>Try <strong>AFL++</strong> - <a href="https://aflplus.plus/" target="_blank">https://aflplus.plus/</a> Community driven, active development, lot of inbuild features compared to vaniall AFL. Support multiple architecutre, blackbox binary fuzzing, custom mutators and has good folks to support.</li>
<li>fuzz various open source software using any of the fuzzer discussed in this workshop.</li>
<li>Try <strong>winafl</strong> - <a href="https://github.com/googleprojectzero/winafl" target="_blank">https://github.com/googleprojectzero/winafl</a> if you want to fuzz windows binaries.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Conclusion and QnA" duration="3">
        <ul>
<li>Fuzzing can help in finding diffrent types of bugs and help to improve overall quality of software.</li>
<li>Fuzzing can save time,resources as it can be automated.</li>
<li>Fuzzing should be part of SDLC.</li>
<li>Sometimes you get broken and non working stuff but you willl earn alot.</li>
<li>But in the end its worth it!</li>
<li>Questions?</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Contact me?" duration="2">
        <p><strong>My youtube channel on fuzzing: </strong><a href="https://www.youtube.com/channel/UCDX-6Auq06Fmwbh7zj5j8_A" target="_blank">Click here</a></p>
<p><strong>Twitter: </strong><a href="https://twitter.com/hardik05" target="_blank">@hardik05</a></p>
<p><strong>email:</strong> hardik05[AT]gmail[DOT]com</p>
<p><strong>Website: </strong><a href="http://fuzzing.in" target="_blank">fuzzing.in</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Thanks" duration="0">
        <p>Thanks everyone, hope you have enjoyed this workshop as much as I have enjoyed delivering it and creating contents and various excericses for it.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://fuzzing.in/elements/codelab-elements/native-shim.js"></script>
  <script src="https://fuzzing.in/elements/codelab-elements/custom-elements.min.js"></script>
  <script src="https://fuzzing.in/elements/codelab-elements/prettify.js"></script>
  <script src="https://fuzzing.in/elements/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
